"""
Test the performance of non-probabilistic NMF for recovering a toy dataset, where 
we vary the level of noise, and use 10% test data.
We repeat this 10 times per noise level and average that.

We use the correct number of latent factors.

I, J, K = 100, 80, 10

The noise levels indicate the percentage of noise, compared to the amount of 
variance in the dataset - i.e. the inverse of the Signal to Noise ratio:
    SNR = std_signal^2 / std_noise^2
    noise = 1 / SNR
We test it for 1%, 10%, 20%, 50%, and 100% noise.
"""

project_location = "/Users/thomasbrouwer/Documents/Projects/libraries/"
import sys
sys.path.append(project_location)

from BNMTF.code.models.nmf_np import NMF
from BNMTF.data_toy.bnmf.generate_bnmf import add_noise, try_generate_M
from BNMTF.code.cross_validation.mask import calc_inverse_M

import numpy, matplotlib.pyplot as plt

##########

fraction_unknown = 0.1
noise_ratios = [ 0, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5 ] # 1/SNR

input_folder = project_location+"BNMTF/data_toy/bnmf/"

repeats = 10
iterations = 1000
I,J,K = 100, 80, 10

init_UV = 'exponential'
expo_prior = 1/10.

metrics = ['MSE', 'R^2', 'Rp']


# Load in data
R_true = numpy.loadtxt(input_folder+"R_true.txt")


# For each noise ratio, generate mask matrices for each attempt
M_attempts = 100
all_Ms = [ 
    [try_generate_M(I,J,fraction_unknown,M_attempts) for r in range(0,repeats)]
    for noise in noise_ratios
]
all_Ms_test = [ [calc_inverse_M(M) for M in Ms] for Ms in all_Ms ]

# Make sure each M has no empty rows or columns
def check_empty_rows_columns(M,fraction):
    sums_columns = M.sum(axis=0)
    sums_rows = M.sum(axis=1)
    for i,c in enumerate(sums_rows):
        assert c != 0, "Fully unobserved row in M, row %s. Fraction %s." % (i,fraction)
    for j,c in enumerate(sums_columns):
        assert c != 0, "Fully unobserved column in M, column %s. Fraction %s." % (j,fraction)
        
for Ms in all_Ms:
    for M in Ms:
        check_empty_rows_columns(M,fraction_unknown)


# For each noise ratio, add that level of noise to the true R
all_R = []
variance_signal = R_true.var()
for noise in noise_ratios:
    tau = 1. / (variance_signal * noise)
    print "Noise: %s%%. Variance in dataset is %s. Adding noise with variance %s." % (100.*noise,variance_signal,1./tau)
    
    R = add_noise(R_true,tau)
    all_R.append(R)
    
    
# We now run the VB algorithm on each of the M's for each noise ratio    
all_performances = {metric:[] for metric in metrics} 
average_performances = {metric:[] for metric in metrics} # averaged over repeats
for (noise,R,Ms,Ms_test) in zip(noise_ratios,all_R,all_Ms,all_Ms_test):
    print "Trying noise ratio %s." % noise
    
    # Run the algorithm <repeats> times and store all the performances
    for metric in metrics:
        all_performances[metric].append([])
    for (repeat,M,M_test) in zip(range(0,repeats),Ms,Ms_test):
        print "Repeat %s of noise ratio %s." % (repeat+1, noise)
    
        nmf = NMF(R,M,K)
        nmf.initialise(init_UV,expo_prior)
        nmf.run(iterations)
    
        # Measure the performances
        performances = nmf.predict(M_test)
        for metric in metrics:
            # Add this metric's performance to the list of <repeat> performances for this noise ratio
            all_performances[metric][-1].append(performances[metric])
            
    # Compute the average across attempts
    for metric in metrics:
        average_performances[metric].append(sum(all_performances[metric][-1])/repeats)
    

    
print "repeats=%s \nnoise_ratios = %s \nall_performances = %s \naverage_performances = %s" % \
    (repeats,noise_ratios,all_performances,average_performances)


'''
repeats=10 
noise_ratios = [0, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5] 
all_performances = {'R^2': [[0.9995476448825061, 0.9996015719301165, 0.9977014834683336, 0.995333359990504, 0.9989171669218556, 0.9989023989710264, 0.9995815981752173, 0.9977542754218551, 0.9995589030416472, 0.9997875425214272], [0.9840083075273499, 0.9876403134638938, 0.9833233590310835, 0.9861499308284364, 0.9844822940046448, 0.9834857475585675, 0.9837756448742655, 0.9846713003157226, 0.9861673598204916, 0.9871470794503925], [0.97163376920039, 0.9692489386240508, 0.972088341044331, 0.9761647482340167, 0.9717181260881824, 0.9778586510304955, 0.966184554321682, 0.9744497879795551, 0.9735917151388707, 0.9737363197236218], [-4.4028161836888004e+32, -3.759088559712833e+38, -1.294424569221832e+28, -3192998662.7071505, 0.9264061063849559, 0.8209657002484525, -3.317052728860476e+30, 0.9259966177389088, 0.8638819977507671, -1.8530424186932566e+28], [-9.04979819635709e+24, -9.783087896122723e+68, -3.736819774299516e+66, -9.409288215082278e+45, -6.750238390004993e+45, -3.500043640759108e+43, -6.207036685437332e+36, -1.2172318304923406e+48, -1.0402515558651151e+27, -4.255321662988398e+18], [-5.322021762905144e+44, -1.9856764045031045e+38, -5.925436358768115e+44, -7.987356278301606e+28, -1.335543045766171e+75, -1.5826268610296532e+77, -9.54254797725046e+46, -8.014381066248156e+55, -5.340070522287999e+46, -6.36146895670925e+55], [-7.245161924177464e+49, -1.5463601857627408e+68, -1.775323988766755e+70, -7.999748148466896e+64, -6.413613197677375e+120, -2.5521149161538797e+74, -3.787110268749836e+70, -9.729831849434912e+38, -5.2167564956988923e+42, -3.8507539352937304e+52]], 'MSE': [[0.017579391110152848, 0.016209412144582734, 0.07979513381961699, 0.16691081480503253, 0.041816340955535332, 0.040723658062362403, 0.01434950136088101, 0.080922889083611671, 0.016077789206501727, 0.0080075315398314695], [0.556647535355145, 0.52920876979532194, 0.6645189579671188, 0.53456025270139673, 0.66919942521440101, 0.584795647797971, 0.57462950681059599, 0.58297133742187979, 0.55375943878567779, 0.55392496374309874], [1.1310102239849043, 1.0947414484766109, 1.1391949320210497, 1.035034344893238, 1.0764653661380836, 1.0326958594090681, 1.164610180709388, 1.0628607539314783, 1.040050098743059, 1.0071058599864846], [1.6793857062974631e+34, 1.6250255661503201e+40, 5.3388994035749167e+29, 118253579083.21465, 2.743625271983281, 7.2453660463483383, 1.4425753854773788e+32, 3.1174230463259618, 5.9480407071845125, 7.6853748444340342e+29], [4.0990355186149488e+26, 3.7821214619636125e+70, 1.4898715875812972e+68, 4.0418900628545628e+47, 2.5005186369469588e+47, 1.657683117342332e+45, 2.7169776260388621e+38, 4.9263478837449507e+49, 4.5830639010511826e+28, 1.9011576623210067e+20], [2.4872759011919353e+46, 8.8480443092101869e+39, 2.6744589827873387e+46, 3.9794158674804488e+30, 5.4537998087055478e+76, 7.6259861064724823e+78, 4.5871390123676107e+48, 3.8108476673176332e+57, 2.5963359535628107e+48, 3.3686621553075175e+57], [4.2583864652103243e+51, 9.3520673467790451e+69, 1.0411042574290839e+72, 4.3336691271956313e+66, 4.2992002381607381e+122, 1.4296131884986913e+76, 2.4500508628948341e+72, 5.0193966554079113e+40, 3.1451570800690035e+44, 1.9380092105757164e+54]], 'Rp': [[0.99977529880816907, 0.99980082124890457, 0.99885921328218641, 0.99766588048267624, 0.9994603542081647, 0.99945323503981032, 0.99979188604526203, 0.99888740252001373, 0.99977966389614426, 0.99989473414419439], [0.99197290223453038, 0.9938300992218867, 0.99166756834496372, 0.99309512773098996, 0.9922471412699817, 0.99181517504353978, 0.99186257355018614, 0.9923252115997373, 0.99312721784438296, 0.99357326587445549], [0.98572965487348108, 0.98451163806119935, 0.98602252897119691, 0.98805267765986327, 0.98578032201494115, 0.98897599935849467, 0.98299084122028357, 0.98722393066304515, 0.98686776145158495, 0.98681899486732272], [0.0050265140944558695, 0.088623442888634663, -0.011479275681817291, 0.00020868376171321576, 0.96261224289442959, 0.91266969574511125, 0.031621824933526665, 0.96230379072357941, 0.93235617145736904, 0.0028854091872550719], [-0.03264316071376152, -0.10334237706819703, -0.02266952757218425, 0.035782601454783201, 0.0028528614426870935, 0.02546949395618275, 0.015822821557324333, 0.05035265259249895, 0.050165277121261335, 0.038555092337905744], [0.036435858876184342, 0.022895574152277543, -0.032157063695105563, 0.013047324333588057, 0.018351543213773559, -0.10699733868630842, -0.026353783457276674, 0.029376785769269723, 0.033591873998306092, -0.004338170628755896], [-0.024072841814460476, -0.0021285471712846702, 0.034972133644170726, 0.044366035648386329, 0.0099709576329952265, 0.016765670312145434, -0.051118797157659296, -0.065178939061203547, 0.022641683782244279, -0.062332563935127976]]} 
average_performances = {'R^2': [0.99866859453244883, 0.98508513368748485, 0.97266749513851969, -3.7590929960142905e+37, -9.8204560938657164e+67, -1.5959822914873151e+76, -6.4136131976773748e+119], 'MSE': [0.048239246208810871, 0.58042158355926055, 1.0783769068293363, 1.6250272600920232e+39, 3.7970201778394254e+69, 7.6805241045595372e+77, 4.2992002381607378e+121], 'Rp': [0.99933684896755248, 0.99255162827146548, 0.98629743491414124, 0.38868285000042579, 0.0060345735108500642, -0.0016147396124047246, -0.007611520811979397]}
'''


# Plot the MSE, R^2 and Rp
for metric in metrics:
    plt.figure()
    x = noise_ratios
    y = average_performances[metric]
    plt.plot(x,y)
    plt.xlabel("Noise ratios missing")
    plt.ylabel(metric)