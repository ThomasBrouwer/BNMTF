"""
Test the performance of non-probabilistic NMTF for recovering a toy dataset, where 
we vary the level of noise.
We repeat this 10 times per fraction and average that.

We use the correct number of latent factors.
I, J, K, L = 100, 80, 5, 5

The noise levels indicate the percentage of noise, compared to the amount of 
variance in the dataset - i.e. the inverse of the Signal to Noise ratio:
    SNR = std_signal^2 / std_noise^2
    noise = 1 / SNR
We test it for 1%, 2%, 5%, 10%, 20%, 50% noise.
"""

project_location = "/Users/thomasbrouwer/Documents/Projects/libraries/"
import sys
sys.path.append(project_location)

from BNMTF.code.models.nmtf_np import NMTF
from BNMTF.data_toy.bnmtf.generate_bnmtf import add_noise, try_generate_M
from BNMTF.code.cross_validation.mask import calc_inverse_M

import numpy, matplotlib.pyplot as plt

##########

fraction_unknown = 0.1
noise_ratios = [ 0, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5 ] # 1/SNR

input_folder = project_location+"BNMTF/data_toy/bnmtf/"

repeats = 10
iterations = 2000
I,J,K,L = 100, 80, 5, 5

init_FG = 'kmeans'
init_S = 'exponential'
expo_prior = 1/10.

metrics = ['MSE', 'R^2', 'Rp']


# Load in data
R_true = numpy.loadtxt(input_folder+"R_true.txt")


# For each noise ratio, generate mask matrices for each attempt
M_attempts = 100
all_Ms = [ 
    [try_generate_M(I,J,fraction_unknown,M_attempts) for r in range(0,repeats)]
    for noise in noise_ratios
]
all_Ms_test = [ [calc_inverse_M(M) for M in Ms] for Ms in all_Ms ]

# Make sure each M has no empty rows or columns
def check_empty_rows_columns(M,fraction):
    sums_columns = M.sum(axis=0)
    sums_rows = M.sum(axis=1)
    for i,c in enumerate(sums_rows):
        assert c != 0, "Fully unobserved row in M, row %s. Fraction %s." % (i,fraction)
    for j,c in enumerate(sums_columns):
        assert c != 0, "Fully unobserved column in M, column %s. Fraction %s." % (j,fraction)
        
for Ms in all_Ms:
    for M in Ms:
        check_empty_rows_columns(M,fraction_unknown)


# For each noise ratio, add that level of noise to the true R
all_R = []
variance_signal = R_true.var()
for noise in noise_ratios:
    tau = 1. / (variance_signal * noise)
    print "Noise: %s%%. Variance in dataset is %s. Adding noise with variance %s." % (100.*noise,variance_signal,1./tau)
    
    R = add_noise(R_true,tau)
    all_R.append(R)
    
    
# We now run the VB algorithm on each of the M's for each noise ratio    
all_performances = {metric:[] for metric in metrics} 
average_performances = {metric:[] for metric in metrics} # averaged over repeats
for (noise,R,Ms,Ms_test) in zip(noise_ratios,all_R,all_Ms,all_Ms_test):
    print "Trying noise ratio %s." % noise
    
    # Run the algorithm <repeats> times and store all the performances
    for metric in metrics:
        all_performances[metric].append([])
    for (repeat,M,M_test) in zip(range(0,repeats),Ms,Ms_test):
        print "Repeat %s of noise ratio %s." % (repeat+1, noise)
    
        nmtf = NMTF(R,M,K,L)
        nmtf.initialise(init_S,init_FG,expo_prior)
        nmtf.run(iterations)
    
        # Measure the performances
        performances = nmtf.predict(M_test)
        for metric in metrics:
            # Add this metric's performance to the list of <repeat> performances for this noise ratio
            all_performances[metric][-1].append(performances[metric])
            
    # Compute the average across attempts
    for metric in metrics:
        average_performances[metric].append(sum(all_performances[metric][-1])/repeats)
    

    
print "repeats=%s \nnoise_ratios = %s \nall_performances = %s \naverage_performances = %s" % \
    (repeats,noise_ratios,all_performances,average_performances)


'''
repeats=10 
noise_ratios = [0, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5] 
all_performances = {'R^2': [[0.9977618217427497, 0.9999642483865081, 0.9995235519112435, 0.9996401284884944, 0.9973291087130546, 0.9974644287923543, 0.9998182631537678, 0.9989551105557226, 0.998093683404878, 0.9975544176598959], [0.9899629394023917, 0.9866032029766125, 0.9888166828122352, 0.987603688401702, 0.9885978357475388, 0.9891819593373499, 0.9886334975270366, 0.9870968782844781, 0.9879917870877409, 0.988950312232051], [0.9748495128216816, 0.9765496132145074, 0.974617875576446, 0.9778829727189384, 0.9717595954653456, 0.9758475470810044, 0.9731435881952403, 0.9795325249367332, 0.9754342875560892, 0.9735240793493118], [0.841579155565285, 0.8948726421464258, -44495492.61819067, -862597009886.9603, -1.2668854636645226, 0.9022590210182452, 0.901351389698418, -97147684.09564237, -877513405.8922911, 0.8868931330958452], [-118735941385004.03, -542128837992558.25, -228296684429.02267, -1.4596019428775688e+19, -29875.69315119856, 0.8517188082806545, 0.8351887466390326, -8064716390.230581, -2006308585.663292, -8223345.524931528], [-1295.6393274774364, -86703312516891.7, -257.55774632190605, -28629619.770905644, -7033264.557492386, -444003862425372.06, 0.6899689971498573, -1.2776980537092035e+42, 0.7612274491135117, 0.7532347259980153], [-1862186570.0580919, -1.108172259649051e+37, -5608379779.4675865, -2902940564131349.5, -7.297605988553715e+26, -3.6260224832057636e+18, -2392.2520029005414, -6.051118938968386e+19, -3.0324164807801315e+19, 0.6403338046850477]], 'MSE': [[1.283016680028799, 0.020599755002031067, 0.29767622591827381, 0.1849792740638497, 1.3361654600050556, 1.2825927725637254, 0.11054270736704598, 0.46485391581407431, 1.149350324217411, 1.162534304503662], [6.5710909677814824, 6.8566132112008153, 6.2128041172041542, 6.5571830648546232, 6.8811907812303978, 6.0893906387102854, 6.0397033898541475, 6.8792855605064327, 6.6447163130183311, 6.1123807276339415], [14.346599081579825, 13.126782169061723, 14.539204252632178, 14.792943850110879, 14.876139808039639, 13.822909094853712, 14.591870966144516, 12.892653102800914, 14.337596518035443, 13.912293818327067], [75.870782418867165, 75.069049752435816, 23165778490.538223, 570161121518190.25, 1306.3554867273219, 65.304689531711205, 58.083432745087528, 50831825416.560242, 568103851792.30359, 67.252222772647826], [74437390767330544.0, 2.9475279896711482e+17, 145804123720407.09, 8.7426892347514133e+21, 18363608.995120086, 96.245519940796441, 106.51842005463506, 5378791651225.8623, 1327239040866.7615, 4940741944.5962124], [828078.00611678918, 57440918289457784.0, 185130.0557259281, 20672296264.33823, 5311689530.5798359, 2.866889109766953e+17, 213.97372089245317, 8.7204748160865645e+44, 160.59009125694999, 150.38910408785745], [1687385724548.9695, 9.5175377059023408e+39, 4855110544826.1172, 2.2906744487412797e+18, 5.7043802236142102e+29, 3.1352912565663485e+21, 1764936.3219393154, 4.97807979138208e+22, 2.3674014755007284e+22, 317.21994131708124]], 'Rp': [[0.99888031401759669, 0.99998216086368552, 0.99976320412231046, 0.99982052467064975, 0.99866610777913112, 0.9987453189554506, 0.99991008372810086, 0.99947842738976922, 0.99904648536155383, 0.99878552105167351], [0.99498125876078369, 0.9933148321459061, 0.99440067866335025, 0.99383364161568044, 0.99432929883639198, 0.99459513963812818, 0.99430207716136887, 0.99356075984939951, 0.993978270838907, 0.99446238005700538], [0.98734876812980354, 0.98822424781064278, 0.98734162869677267, 0.98891703529725117, 0.98577981975530815, 0.98789215130356245, 0.98660674228201661, 0.98972543939394586, 0.9877096898464669, 0.98670129911008431], [0.91841739810346568, 0.94841821417256722, 0.027931652779525463, 0.0070275465234739638, 0.48617374755227782, 0.94994071540364799, 0.94960653469582623, -0.029945300213811928, 0.029095499513705853, 0.94181234830903349], [-0.02576017054996111, -0.0012777541169250422, 0.14966304492507532, 0.040090164109107727, -0.059437577457751883, 0.92292335671459202, 0.91428795410949681, -0.050331810715965423, -0.012222945140772514, -0.043644897649199765], [0.0016799568495092139, 0.043181508553630711, 0.035912140626434448, 0.012113402633041538, 0.028197554789386528, 0.0043061418367188915, 0.83664656593906483, -0.037114019640318116, 0.8733465577168521, 0.86809191325471191], [-0.091837397785982447, -0.020025350170963394, 0.033097746310890595, 0.026405969265087682, -0.028492631934035974, -0.035116571322598392, 0.044460266540813059, -0.049135219825617686, 0.03743049254086437, 0.80039376412392838]]} 
average_performances = {'R^2': [0.99861047628086674, 0.98834387838091364, 0.9753141596915299, -86361616646.640656, -1.4596680531931028e+18, -1.2776980537092035e+41, -1.1081722597220271e+36], 'MSE': [0.72923114194839278, 6.484435877199461, 14.123899266158592, 57080322297553.75, 8.743058577456262e+20, 8.7204748160865643e+43, 9.5175377064727788e+38], 'Rp': [0.999307814793992, 0.99417583375669205, 0.98762468216258537, 0.5228478356839712, 0.18342893642276961, 0.26663617225590319, 0.071718106774238621]}
'''


# Plot the MSE, R^2 and Rp
for metric in metrics:
    plt.figure()
    x = noise_ratios
    y = average_performances[metric]
    plt.plot(x,y)
    plt.xlabel("Noise ratios missing")
    plt.ylabel(metric)